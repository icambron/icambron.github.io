<html><head lang="en"><meta charset="utf-8" /><meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible" /><meta content="width=device-width, initial-scale=1.0" name="viewport" /><title>Transducer Composition</title><link href="/stylesheets/main.css" rel="stylesheet" /><script src="/javascripts/main.js"></script></head><body><div class="navbar navbar-inverse"><div class="navbar-header"><button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse"><span class="sr-only">Toggle navigation</span><span class="fa fa-bars"></span></button><a class="navbar-brand" href="/">Isaac</a></div><div class="collapse navbar-collapse"><ul class="nav navbar-nav"><li><a href="/">About</a></li><li><a href="/projects.html">OSS Projects</a></li><li><a href="/resume.html">Resume</a></li><li><a href="/blog">Blog</a></li></ul></div></div><div class="container"><div id="blog"><div id="blog-info"><div id="blog-info-content"><h4>Isaac Cambron</h4><p><a href="http://twitter.com/icambron">@icambron</a></p><p><i class="fa fa-caret-left"></i> <a href="/blog">Back to blog</a></p></div></div><div id="blog-articles"><div class="blog-article"><div class="blog-content"><h2><a href="/blog/2014/12/13/transducer-composition.html">Transducer Composition</a></h2><p class="blog-date">Dec 13, 2014</p><p>My <a href="http://zensight.co">startup</a> has been building our product in Clojure. It&rsquo;s been awesome, and overall, it&rsquo;s been pretty easy to learn and be productive with, since our team was already in a functional programming mindset. But we&rsquo;re still learning some of the edges. Specifically, today I was trying out a newish feature called <a href="http://clojure.org/transducers">transducers</a>, which allow you to compose transformations on data without having to care much about its &ldquo;container&rdquo; type, so long as that container provides a way to reduce itself.</p>

<p>Just playing around with it, I got confused for a bit that my transducers kept composing in the opposite order I expected. Specifically, this (which I&rsquo;ll explain in a second):</p>
<pre class="highlight clojure"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">doubler</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="nb">into</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">doubler</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">inc</span><span class="p">))</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="c1">;=&gt; (3 5 7)</span><span class="w">

</span><span class="c1">;;vs the ol' fashioned, non-tranducery:</span><span class="w">

</span><span class="p">((</span><span class="nb">comp</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">doubler</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="n">%</span><span class="p">))</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="c1">;=&gt; (4 6 8)</span><span class="w">
</span></code></pre>
<p>It turns out I&rsquo;d missed that the docs mention that explicitly:</p>

<blockquote>
<p>The composed xf transducer will be invoked left-to-right&hellip;</p>
</blockquote>

<p>It took me a bit to figure out what was happening at all, and when it dawned on me (&ldquo;oh, it goes the other way!&rdquo;), I wondered <em>why the hell does it do that?</em> I asked about it on the ClojureScript IRC channel, where <a href="https://twitter.com/swannodette">David Nolen</a> told me to go look at the source. That&rsquo;s a totally fine answer (it&rsquo;s not his job to sit around and write out detailed answers to my questions), but it&rsquo;s of course more useful if there&rsquo;s an explanation written up, hence this post.</p>

<p>I actually didn&rsquo;t look at the source; instead, I took a nap and when I woke up I was pretty confident I knew the answer.</p>

<h2>A quick review of composition</h2>

<p>The order of composition obviously matters; <code>f(g(x))</code> is not the same of <code>g(f(x))</code>.</p>
<pre class="highlight clojure"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">doubler</span><span class="w"> </span><span class="p">[</span><span class="n">x</span><span class="p">]</span><span class="w"> </span><span class="p">(</span><span class="nb">*</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="n">x</span><span class="p">))</span><span class="w">

</span><span class="p">((</span><span class="nb">comp</span><span class="w"> </span><span class="n">doubler</span><span class="w"> </span><span class="nb">inc</span><span class="p">)</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">;=&gt; 6, the result of (doubler (inc 2))</span><span class="w">

</span><span class="p">((</span><span class="nb">comp</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="n">doubler</span><span class="p">)</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">;=&gt; 5, the result (inc (doubler 2))</span><span class="w">
</span></code></pre>
<p>If you want to apply that composition to each element of a sequence, you&rsquo;d do something like:</p>
<pre class="highlight clojure"><code><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="n">doubler</span><span class="w"> </span><span class="nb">inc</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="c1">;=&gt; (4 6 8)</span><span class="w">
</span></code></pre>
<p>But perhaps you have a bunch of functions that operate on sequences, and you want to compose <em>those</em>. You end up with the uglier, less efficient, and no less correct composition of maps:</p>
<pre class="highlight clojure"><code><span class="p">((</span><span class="nb">comp</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="n">doubler</span><span class="w"> </span><span class="n">%</span><span class="p">)</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">inc</span><span class="w"> </span><span class="n">%</span><span class="p">))</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="c1">;=&gt; (4 6 8)</span><span class="w">
</span></code></pre>
<h2>Transducers, briefly</h2>

<p>Transducers manage to compose the same sort of transformations, but do it in a way that doesn&rsquo;t create intermediate sequences (even lazy ones) and for which the transformations themselves are agnostic about what kind of container they&rsquo;re transforming elements from (or into). It does this by defining various transformations (e.g. <code>map</code>, <code>take</code>, <code>filter</code>, etc) in terms of <code>reduce</code> and then parameterizing them with the reduce function itself. So <code>map</code> in the transducer world doesn&rsquo;t mean &ldquo;take each element from a sequence and call this function on them and put the results in another sequence&rdquo;. It means &ldquo;given some way (let&rsquo;s call it foo) of reducing something,  give me a way of reducing things that increments each thing and then reduces it with foo&rdquo;.</p>

<p>You create a transducer by calling one of the standard listy functions without a collection arg, like <code>(map inc)</code>. That transducer can be handed to pieces of machinery that know what transducers mean, like the <code>transduce</code> function:</p>
<pre class="highlight clojure"><code><span class="p">(</span><span class="nf">transduce</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">inc</span><span class="p">)</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="c1">;=&gt; [2 3 4]</span><span class="w">
</span><span class="p">(</span><span class="nf">transduce</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">inc</span><span class="p">)</span><span class="w"> </span><span class="nb">+</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="c1">;=&gt; 9</span><span class="w">
</span></code></pre>
<p>What&rsquo;s really neat is that different containery things can implement <code>reduce</code> differently without having to define its own specific transformations (or even make you do it differently for your different use cases). For example, you could use some transducers you built to transform a vector, while your core.async channels can use <em>the same transducers</em> to transform values pushed through them. That works because those async channels can provide their own definition of reduce, and the transducers only depend on that having the right shape.</p>

<p>OK, so that&rsquo;s a terse introduction, but for more, go watch <a href="https://www.youtube.com/watch?v=6mTbuzafcII">the StrangeLoop talk</a>.</p>

<h2>Reversals</h2>

<p>So why does composing transducers mean they get evaluated &ldquo;backwards&rdquo; or &ldquo;inside out&rdquo;? Well, on reflection, it makes a lot of sense. What transducers really do is <em>transform reducing functions</em>, not actual values; they take one reducing function and return another one that works by transforming its values and passing the results to that passed-in reducing function. When you compose them, you&rsquo;re using the function returned by the &ldquo;inner&rdquo; transducer as the reduction function for the &ldquo;outer&rdquo; transducer. So if I have <code>(comp (map double) (map inc))</code>, I&rsquo;m saying that <code>(map inc)</code> provides a reducing function that takes a value, increments it, and feeds into the reducing function it gets passed. I&rsquo;m then passing <em>that</em> reducing function into the doubling tansducer, which returns another reducing function that doubles the values and <em>then</em> feeds the answer into the map-incrementing reducer the doubler took as an argument. So double then inc.</p>

<p><strong>Instead of bubbling values out like in a simple compose, you&rsquo;re building a set of concentric spheres, each capable of taking a value from the outside and pushing it in.</strong></p>

<p>I&rsquo;ll make that more concrete in a moment, but first, note that this inside-outness is a common feature of composed higher order functions that use their arguments as their &ldquo;outermost&rdquo; invocation. Compare our original composed maps to these, which also don&rsquo;t use transducers at all:</p>
<pre class="highlight clojure"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">pre-inc</span><span class="w"> </span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">f</span><span class="w"> </span><span class="p">(</span><span class="nb">inc</span><span class="w"> </span><span class="n">%</span><span class="p">)))</span><span class="w">
</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">pre-doubler</span><span class="w"> </span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">f</span><span class="w"> </span><span class="p">(</span><span class="nf">doubler</span><span class="w"> </span><span class="n">%</span><span class="p">)))</span><span class="w">

</span><span class="p">(((</span><span class="nb">comp</span><span class="w"> </span><span class="n">pre-doubler</span><span class="w"> </span><span class="n">pre-inc</span><span class="p">)</span><span class="w"> </span><span class="nb">identity</span><span class="p">)</span><span class="w"> </span><span class="mi">2</span><span class="p">)</span><span class="w"> </span><span class="c1">;=&gt; 5</span><span class="w">

</span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="p">((</span><span class="nb">comp</span><span class="w"> </span><span class="n">pre-doubler</span><span class="w"> </span><span class="n">pre-inc</span><span class="p">)</span><span class="w"> </span><span class="nb">identity</span><span class="p">)</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="c1">;=&gt; (3 5 7), all backwardslike</span><span class="w">
</span></code></pre>
<p>If that makes sense to you, the next part will be easy. One interesting way to better understand all this is to implement a simplified version of transducers. We&rsquo;ll skip a bunch of complications, like stateful transducers, and we won&rsquo;t bother with a really important thing about transducers: making the actual reduction polymorphic. But here goes:</p>
<pre class="highlight clojure"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">my-transduce</span><span class="w"> </span><span class="p">[</span><span class="n">xform</span><span class="w"> </span><span class="n">f</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="n">coll</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">let</span><span class="w"> </span><span class="p">[</span><span class="n">reducer</span><span class="w"> </span><span class="nb">reduce</span><span class="w"> </span><span class="c1">;todo: this should depend on the type of coll</span><span class="w">
        </span><span class="n">doit</span><span class="w"> </span><span class="p">(</span><span class="nf">xform</span><span class="w"> </span><span class="n">f</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nf">reducer</span><span class="w"> </span><span class="n">doit</span><span class="w"> </span><span class="n">init</span><span class="w"> </span><span class="n">coll</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">my-into</span><span class="w"> </span><span class="p">[</span><span class="n">to</span><span class="w"> </span><span class="n">xform</span><span class="w"> </span><span class="n">from</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">my-transduce</span><span class="w"> </span><span class="n">xform</span><span class="w"> </span><span class="nb">conj</span><span class="w"> </span><span class="n">to</span><span class="w"> </span><span class="n">from</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">my-map</span><span class="w"> </span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">rf</span><span class="p">]</span><span class="w"> </span><span class="c1">;rf is like conj or +</span><span class="w">
    </span><span class="p">(</span><span class="k">fn</span><span class="w"> </span><span class="p">[</span><span class="n">result</span><span class="w"> </span><span class="n">input</span><span class="p">]</span><span class="w"> </span><span class="c1">;can be passed to a reducing function</span><span class="w">
      </span><span class="p">(</span><span class="nf">rf</span><span class="w"> </span><span class="n">result</span><span class="w"> </span><span class="p">(</span><span class="nf">f</span><span class="w"> </span><span class="n">input</span><span class="p">)))))</span><span class="w"> </span><span class="c1">;this is the inversion that answers the question</span><span class="w">

</span><span class="p">(</span><span class="nf">my-into</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nb">comp</span><span class="w"> </span><span class="p">(</span><span class="nf">my-map</span><span class="w"> </span><span class="n">doubler</span><span class="p">)</span><span class="w"> </span><span class="p">(</span><span class="nf">my-map</span><span class="w"> </span><span class="nb">inc</span><span class="p">))</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="mi">3</span><span class="p">])</span><span class="w"> </span><span class="c1">;=&gt; [3,5,7]</span><span class="w">
</span></code></pre>
<p>That&rsquo;s the whole thing. <code>my-map</code> returns a transducer, i.e. a function that takes a reducing function and returns a different one. Since it does its transformation and then delegates the actual core reduction work to its argument, the order of composition <em>from the standpoint of the individual values</em> is&hellip;well, I still say it&rsquo;s backwards. But it makes good sense.</p>
<a class="pull-right" href="http://github.com/icambron/isaaccambron.com/tree/master/source/blog/2014-12-13-transducer-composition.html.markdown">Source</a></div></div></div></div></div><script type="text/javascript">!function(e,a,t,n,c,o,s){e.GoogleAnalyticsObject=c,e[c]=e[c]||function(){(e[c].q=e[c].q||[]).push(arguments)},e[c].l=1*new Date,o=a.createElement(t),s=a.getElementsByTagName(t)[0],o.async=1,o.src=n,s.parentNode.insertBefore(o,s)}(window,document,"script","//www.google-analytics.com/analytics.js","ga"),ga("create","UA-52148016-1","auto"),ga("send","pageview");</script></body></html>